name: Build Plugins
on: [workflow_dispatch]

concurrency:
  group: build_plugins_${{ github.ref_name }}
  cancel-in-progress: true

jobs:
  prepare:
    name: Prepare Repository Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Setup jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
      - name: Read repo_urls.txt and create matrix
        id: set-matrix
        run: |
          # Read repo_urls.txt, filter out empty lines and comments, create JSON matrix
          repos=$(cat repo_urls.txt | grep -v '^$' | grep -v '^#' | jq -R -s -c '
            split("\n") |
            map(select(length > 0)) |
            map(
              . as $url |
              if ($url | test("github\\.com/([^/]+)/([^/]+)")) then
                ($url | capture("github\\.com/(?<owner>[^/]+)/(?<repo>[^/]+)")) as $parts |
                {
                  repo_url: $url,
                  display_name: ($parts.owner + "/" + ($parts.repo | split("/") | .[0]))
                }
              else
                {repo_url: $url, display_name: $url}
              end
            )')
          echo "matrix={\"include\":$repos}" >> $GITHUB_OUTPUT
          count=$(echo $repos | jq 'length')
          echo "Found $count repositories"

  build:
    name: Build ${{ matrix.display_name }}
    needs: prepare
    permissions:
      id-token: write
      contents: write
      attestations: write
    runs-on: windows-2022
    defaults:
      run:
        shell: pwsh
    env:
      IsCI: true
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}
    steps:
      - name: Checkout build script
        uses: actions/checkout@v4
        with:
          path: build-scripts
      - name: Extract repository name
        id: repo-info
        run: |
          $repoUrl = "${{ matrix.repo_url }}"
          # Only handle GitHub URLs, skip everything else
          if ($repoUrl -match 'github\.com/([^/]+)/([^/]+)') {
              $owner = $Matches[1]
              $repo = $Matches[2]
              # Handle URLs with /tree/branch or /tree/branch/path
              if ($repo -match '^([^/]+)') {
                  $repo = $Matches[1]
              }
              echo "owner=$owner" >> $env:GITHUB_OUTPUT
              echo "repo=$repo" >> $env:GITHUB_OUTPUT
              echo "repo_name=$repo" >> $env:GITHUB_OUTPUT
              echo "skip=false" >> $env:GITHUB_OUTPUT
          } else {
              Write-Host "Skipping non-GitHub repository: $repoUrl"
              echo "skip=true" >> $env:GITHUB_OUTPUT
          }
      - name: Checkout Repository
        if: steps.repo-info.outputs.skip != 'true'
        id: checkout-repo
        continue-on-error: true
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.repo-info.outputs.owner }}/${{ steps.repo-info.outputs.repo }}
          submodules: recursive
          fetch-depth: 0
          path: plugin-repo
      - name: Checkout Repository (without submodules)
        if: steps.repo-info.outputs.skip != 'true' && steps.checkout-repo.outcome == 'failure'
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.repo-info.outputs.owner }}/${{ steps.repo-info.outputs.repo }}
          submodules: false
          fetch-depth: 0
          path: plugin-repo
      - name: Checkout to last commit before 2025-08-01
        if: steps.repo-info.outputs.skip != 'true'
        run: |
          cd plugin-repo
          # Find the last commit before 2025-08-01 00:00:00 UTC+8
          $targetCommit = git rev-list -n 1 --first-parent --before="2025-08-01T00:00:00+08:00" HEAD
          if ($targetCommit) {
            Write-Host "Checking out to commit before 2025-08-01: $targetCommit"
            git checkout $targetCommit
            # Update submodules if they exist (continue even if some fail)
            if (Test-Path .gitmodules) {
              Write-Host "Updating submodules..."
              try {
                git submodule update --init --recursive 2>&1 | Write-Host
              } catch {
                Write-Warning "Some submodules failed to update: $_"
              }
              # Reset error code to allow workflow to continue
              $global:LASTEXITCODE = 0
            }
          } else {
            Write-Host "No commits found before 2025-08-01, using current HEAD"
          }
          cd ..
      - name: Skip non-GitHub repositories
        if: steps.repo-info.outputs.skip == 'true'
        run: |
          echo "Skipping non-GitHub repository: ${{ matrix.repo_url }}"
      - name: Generate release tag (UTC+8)
        if: steps.repo-info.outputs.skip != 'true'
        id: generate-tag
        run: |
          # Get current time in UTC+8 (Asia/Taipei)
          $taipeiTime = [System.TimeZoneInfo]::ConvertTimeBySystemTimeZoneId([DateTime]::UtcNow, 'Taipei Standard Time')
          $datePart = $taipeiTime.ToString('yy-MM-dd')

          cd plugin-repo
          git fetch --tags
          $tags = git tag --list "$datePart-*"

          $maxNumber = 0
          foreach ($tag in $tags) {
              if ($tag -match '-(\d{2})$') {
                  $currentNumber = [int]$Matches[1]
                  if ($currentNumber -gt $maxNumber) {
                      $maxNumber = $currentNumber
                  }
              }
          }

          $nextNumber = $maxNumber + 1
          $newTag = "{0}-{1:D2}" -f $datePart, $nextNumber
          echo "new_tag=$newTag" >> $env:GITHUB_OUTPUT
          echo "TAG=$newTag" >> $env:GITHUB_ENV
          cd ..
      - name: Setup .NET
        if: steps.repo-info.outputs.skip != 'true'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x
      - name: Download Dalamud
        if: steps.repo-info.outputs.skip != 'true'
        run: |
          Invoke-WebRequest -Uri "https://github.com/yanmucorp/Dalamud/releases/download/25-12-08-01/latest.7z" -OutFile "latest.7z"
          7z x latest.7z -o"${{ github.workspace }}/dalamud/"
      - name: Define VERSION
        if: steps.repo-info.outputs.skip != 'true'
        run: |
          cd plugin-repo
          $commit = git rev-parse --short HEAD
          $repoName = "${{ steps.repo-info.outputs.repo_name }}"
          $branch = git rev-parse --abbrev-ref HEAD

          "$repoName" | Out-File -FilePath VERSION -Encoding utf8
          "$branch" | Out-File -FilePath VERSION -Append -Encoding utf8
          "$commit" | Out-File -FilePath VERSION -Append -Encoding utf8
          cd ..
      - name: Find .csproj file and extract version
        if: steps.repo-info.outputs.skip != 'true'
        id: find-csproj
        run: |
          cd plugin-repo
          # Find .csproj file (exclude test projects and common patterns)
          $csprojFile = Get-ChildItem -Recurse -Filter "*.csproj" | Where-Object {
            $_.FullName -notmatch "\\obj\\" -and
            $_.FullName -notmatch "\\bin\\" -and
            $_.Name -notmatch "test"
          } | Select-Object -First 1
          if (-not $csprojFile) {
            Write-Error "Error: No .csproj file found"
            exit 1
          }
          $relativePath = $csprojFile.FullName.Replace((Get-Location).Path + "\", "")
          Write-Host "Found .csproj: $relativePath"
          echo "csproj_file=$relativePath" >> $env:GITHUB_OUTPUT

          # Extract version from .csproj file
          [xml]$csprojContent = Get-Content $csprojFile.FullName
          $version = $null

          # Try to get Version property
          if ($csprojContent.Project.PropertyGroup.Version) {
            $version = $csprojContent.Project.PropertyGroup.Version | Select-Object -First 1
          }
          # Fallback to AssemblyVersion
          elseif ($csprojContent.Project.PropertyGroup.AssemblyVersion) {
            $version = $csprojContent.Project.PropertyGroup.AssemblyVersion | Select-Object -First 1
          }
          # Fallback to FileVersion
          elseif ($csprojContent.Project.PropertyGroup.FileVersion) {
            $version = $csprojContent.Project.PropertyGroup.FileVersion | Select-Object -First 1
          }

          if ($version) {
            Write-Host "Extracted version: $version"
            echo "version=$version" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "No version found in .csproj, using 'unknown'"
            echo "version=unknown" >> $env:GITHUB_OUTPUT
          }
          cd ..
      - name: Restore Dependencies
        if: steps.repo-info.outputs.skip != 'true'
        run: |
          cd plugin-repo
          dotnet restore "${{ steps.find-csproj.outputs.csproj_file }}" /p:DalamudLibPath="${{ github.workspace }}\dalamud\"
          cd ..
      - name: Build
        if: steps.repo-info.outputs.skip != 'true'
        run: |
          cd plugin-repo
          dotnet build "${{ steps.find-csproj.outputs.csproj_file }}" --configuration Release -v n /p:DALAMUD_HOME="${{ github.workspace }}/dalamud" /p:SolutionDir="$(Get-Location)" -o ./bin/Release
          cd ..
        env:
          DOTNET_CLI_TELEMETRY_OPTOUT: true
      - name: Upload artifact
        if: steps.repo-info.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.repo-info.outputs.repo_name }}-v${{ steps.find-csproj.outputs.version }}
          path: plugin-repo/bin/Release
          if-no-files-found: error
